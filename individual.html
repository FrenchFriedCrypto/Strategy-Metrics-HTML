<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Trade Metrics Dashboard - Multiple Files</title>
  <!-- PapaParse for CSV parsing -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.3.2/papaparse.min.js"></script>
  <!-- Chart.js for charts -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <style>
    body {
      font-family: Arial, sans-serif;
      margin: 20px;
      background: #f8f8f8;
    }
    header nav {
      text-align: center;
      margin-bottom: 20px;
    }
    header nav button {
      margin-right: 10px;
      padding: 10px 15px;
      font-size: 16px;
      cursor: pointer;
    }
    h1, h2 {
      text-align: center;
    }
    /* Checkbox Section */
    #sectionOptions {
      text-align: center;
      margin-bottom: 20px;
    }
    #sectionOptions label {
      margin: 0 10px;
      font-size: 16px;
    }
    /* Editable CSV Files List */
    #csvListContainer {
      text-align: center;
      margin-bottom: 20px;
    }
    #csvFilesList {
      width: 400px;
      height: 150px;
      font-size: 14px;
    }
    /* Risk Size Input Field */
    #riskSizeContainer {
      text-align: center;
      margin-bottom: 20px;
    }
    #riskSizeContainer label, #riskSizeContainer input {
      font-size: 16px;
    }
    /* Summary Section */
    .summary {
      display: flex;
      flex-wrap: wrap;
      justify-content: center;
      gap: 20px;
      margin-bottom: 20px;
    }
    .summary-item {
      background: #fff;
      border: 1px solid #ccc;
      padding: 10px 15px;
      border-radius: 5px;
      width: 200px;
      text-align: center;
      box-shadow: 1px 1px 3px rgba(0,0,0,0.1);
    }
    .summary-item strong {
      display: block;
      margin-bottom: 5px;
      font-size: 1.1em;
    }
    /* Distribution Section */
    .distribution {
      background: #fff;
      padding: 15px;
      border: 1px solid #ccc;
      border-radius: 5px;
      margin: 20px auto;
      max-width: 95%;
      box-shadow: 1px 1px 3px rgba(0,0,0,0.1);
    }
    /* Container for the charts */
    .chartsContainer {
      display: flex;
      justify-content: center;
      gap: 20px;
      flex-wrap: wrap;
      margin-bottom: 20px;
    }
    .chartsContainer > div {
      text-align: center;
    }
    .file-container {
      margin-bottom: 60px;
      border-bottom: 2px solid #ccc;
      padding-bottom: 30px;
    }
  </style>
</head>
<body>
  <!-- Navigation Header -->
  <header>
    <nav>
      <button onclick="window.location.href='index.html'">Summary</button>
      <button onclick="window.location.href='capped_pnl.html'">Capped PnL</button>
      <button onclick="window.location.href='individual.html'">Individual symbol</button>
    </nav>
  </header>

  <h1>Multi-file Trade Metrics Dashboard</h1>

  <!-- Section Options Checkboxes -->
  <div id="sectionOptions">
    <label><input type="checkbox" id="chkAllTrades" checked> All Trades</label>
    <label><input type="checkbox" id="chkLongTrades" checked> Long Trades</label>
    <label><input type="checkbox" id="chkShortTrades" checked> Short Trades</label>
  </div>

  <!-- Editable CSV Files List -->
  <div id="csvListContainer">
    <h2>CSV Files to Load (one filename per line, located in the "data" folder)</h2>
    <textarea id="csvFilesList" placeholder="ADAUSDT.csv
AVAXUSDT.csv
BCHUSDT.csv
BNBUSDT.csv
BTCUSDT.csv
ETHUSDT.csv
LINKUSDT.csv
SOLUSDT.csv
TRXUSDT.csv">
ADAUSDT.csv
AVAXUSDT.csv
BCHUSDT.csv
BNBUSDT.csv
BTCUSDT.csv
ETHUSDT.csv
LINKUSDT.csv
SOLUSDT.csv
TRXUSDT.csv</textarea>
    <br>
    <button id="loadFilesButton">Load Files</button>
  </div>

  <!-- Global Risk Size Input -->
  <div id="riskSizeContainer">
    <label for="riskSize">Risk Size per Trade:</label>
    <input type="number" id="riskSize" value="55.55" step="any" style="width:100px; margin-left:5px;">
  </div>

  <!-- The file containers will be dynamically added here -->
  <div id="filesContainer"></div>

  <script>
    /****************************
     * Global variables & helpers
     ****************************/
    // An object to hold the parsed CSV data for each file (keyed by prefix)
    const fileDataMap = {};

    // Helper: parse daily unrealized values from a trade
    function getDailyUnrealizedValues(trade) {
      let values = [];
      if (trade['Daily unrealized'] && trade['Daily unrealized'].trim() !== "") {
        try {
          const parsed = JSON.parse(trade['Daily unrealized']);
          if (Array.isArray(parsed)) {
            parsed.forEach(val => {
              let num = parseFloat(val);
              if (!isNaN(num)) values.push(num);
            });
          }
        } catch (e) {
          console.error("Error parsing Daily unrealized for trade", trade, e);
        }
      }
      return values;
    }

    /***********************
     * Chart update functions
     * (Same as your original functions; omitted here for brevity.)
     ***********************/
    function updateDistributionChart(riskSize, data, canvasId) {
      // ... (existing code unchanged)
      const allValues = [];
      data.forEach(trade => {
        const vals = getDailyUnrealizedValues(trade);
        allValues.push(...vals);
      });
      const ratios = allValues.map(val => val / riskSize);
      const binEdges = [-Infinity, -10, -5, -2, -1, -0.5, 0, 0.5, 1, 2, 5, 10, 100, Infinity];
      let bins = new Array(binEdges.length - 1).fill(0);
      const labels = [];
      for (let i = 0; i < binEdges.length - 1; i++) {
        if (binEdges[i] === -Infinity) {
          labels.push("< -10");
        } else if (binEdges[i+1] === Infinity) {
          labels.push("> 100");
        } else {
          labels.push(`${binEdges[i]} to ${binEdges[i+1]}`);
        }
      }
      ratios.forEach(ratio => {
        for (let i = 0; i < bins.length; i++) {
          if (ratio >= binEdges[i] && ratio < binEdges[i+1]) {
            bins[i]++;
            break;
          }
        }
      });
      const totalPoints = ratios.length;
      const percentages = bins.map(count => totalPoints ? (count / totalPoints) * 100 : 0);
      const ctx = document.getElementById(canvasId).getContext('2d');
      if (window[canvasId + "Chart"]) {
        window[canvasId + "Chart"].data.labels = labels;
        window[canvasId + "Chart"].data.datasets[0].data = percentages;
        window[canvasId + "Chart"].update();
      } else {
        window[canvasId + "Chart"] = new Chart(ctx, {
          type: 'bar',
          data: {
            labels: labels,
            datasets: [{
              label: 'Percentage of Trades',
              data: percentages,
              backgroundColor: 'rgba(54, 162, 235, 0.6)',
              borderColor: 'rgba(54, 162, 235, 1)',
              borderWidth: 1
            }]
          },
          options: {
            scales: {
              x: { title: { display: true, text: 'Risk Ratio Tranches' } },
              y: { beginAtZero: true, title: { display: true, text: 'Percentage of Trades (%)' } }
            }
          }
        });
      }
    }

    function updatePnlDistributionChart(riskSize, data, canvasId) {
      // ... (existing code unchanged)
      const binEdges = [-Infinity, -10, -5, -2, -1, -0.5, 0, 0.5, 1, 2, 5, 10, 100, Infinity];
      let bins = new Array(binEdges.length - 1).fill(0);
      let durationSums = new Array(binEdges.length - 1).fill(0);
      let durationCounts = new Array(binEdges.length - 1).fill(0);
      const labels = [];
      for (let i = 0; i < binEdges.length - 1; i++) {
        if (binEdges[i] === -Infinity) {
          labels.push("< -10");
        } else if (binEdges[i+1] === Infinity) {
          labels.push("> 100");
        } else {
          labels.push(`${binEdges[i]} to ${binEdges[i+1]}`);
        }
      }
      data.forEach((trade, index) => {
        let pnl = parseFloat(trade['PnL']) || 0;
        let normalizedPnl = pnl / riskSize;
        let duration = NaN;
        if (trade['Entry Dates'] && trade['Entry Dates'].trim() !== "") {
          try {
            let entryDatesStr = trade['Entry Dates'].replace(/'/g, '"');
            let entryDatesArray = JSON.parse(entryDatesStr);
            if (Array.isArray(entryDatesArray) && entryDatesArray.length > 0) {
              let firstEntryDate = entryDatesArray[0].trim();
              if (!firstEntryDate.includes('T')) {
                firstEntryDate = firstEntryDate.replace(' ', 'T');
              }
              let startDate = new Date(firstEntryDate);
              let exitDateStr = (trade['Exit Date'] || "").trim();
              if (exitDateStr && !exitDateStr.includes('T')) {
                exitDateStr = exitDateStr.replace(' ', 'T');
              }
              let exitDate = new Date(exitDateStr);
              duration = Math.round((exitDate - startDate) / (1000 * 60 * 60 * 24));
            }
          } catch (e) {
            console.error("Error computing duration for trade index", index, e);
          }
        }
        for (let i = 0; i < bins.length; i++) {
          if (normalizedPnl >= binEdges[i] && normalizedPnl < binEdges[i+1]) {
            bins[i]++;
            if (!isNaN(duration)) {
              durationSums[i] += duration;
              durationCounts[i]++;
            }
            break;
          }
        }
      });
      const totalTrades = data.length;
      const percentages = bins.map(count => (totalTrades ? (count / totalTrades) * 100 : 0));
      const avgDurations = durationSums.map((sum, i) => (durationCounts[i] ? sum / durationCounts[i] : 0));
      const multilineLabels = labels.map((lab, i) => [lab, bins[i] + " T"]);
      const ctx = document.getElementById(canvasId).getContext('2d');
      if (window[canvasId + "Chart"]) {
        window[canvasId + "Chart"].data.labels = multilineLabels;
        window[canvasId + "Chart"].data.datasets[0].data = percentages;
        window[canvasId + "Chart"].data.datasets[1].data = avgDurations;
        window[canvasId + "Chart"].update();
      } else {
        window[canvasId + "Chart"] = new Chart(ctx, {
          data: {
            labels: multilineLabels,
            datasets: [
              {
                type: 'bar',
                label: 'Percentage of Trades',
                data: percentages,
                backgroundColor: 'rgba(255, 99, 132, 0.6)',
                borderColor: 'rgba(255, 99, 132, 1)',
                borderWidth: 1,
                yAxisID: 'y'
              },
              {
                type: 'line',
                label: 'Average Trade Duration (days)',
                data: avgDurations,
                borderColor: 'rgba(0, 0, 0, 1)',
                backgroundColor: 'rgba(0, 0, 0, 1)',
                borderWidth: 2,
                fill: false,
                yAxisID: 'y2',
                tension: 0,
                pointStyle: 'circle',
                pointRadius: 4,
                pointHoverRadius: 6
              }
            ]
          },
          options: {
            scales: {
              x: { title: { display: true, text: 'Risk Ratio Tranches' } },
              y: { beginAtZero: true, title: { display: true, text: 'Percentage of Trades (%)' } },
              y2: {
                position: 'right',
                grid: { drawOnChartArea: false },
                beginAtZero: true,
                title: { display: true, text: 'Average Trade Duration (days)' }
              }
            }
          }
        });
      }
    }

    function updatePortfolioUnrealizedChart(data, canvasId) {
      // ... (existing code unchanged)
      const timeline = {};
      let minTime = Infinity;
      let maxTime = -Infinity;
      data.forEach(trade => {
        if (trade['Entry Dates'] && trade['Entry Dates'].trim() !== "") {
          try {
            let entryDatesStr = trade['Entry Dates'].replace(/'/g, '"');
            let entryDatesArray = JSON.parse(entryDatesStr);
            if (!Array.isArray(entryDatesArray) || entryDatesArray.length === 0) return;
            let tradeStart = new Date(entryDatesArray[0].trim());
            if (isNaN(tradeStart.getTime())) return;
            const unrealizedStr = trade['Daily unrealized'];
            if (!unrealizedStr || unrealizedStr.trim() === "") return;
            let unrealizedArr = JSON.parse(unrealizedStr);
            if (!Array.isArray(unrealizedArr)) return;
            unrealizedArr.forEach((val, i) => {
              const value = parseFloat(val);
              if (isNaN(value)) return;
              const measurementTime = new Date(tradeStart.getTime() + i * 4 * 60 * 60 * 1000);
              const binTime = new Date(measurementTime);
              const hours = binTime.getHours();
              const binHour = Math.floor(hours / 4) * 4;
              binTime.setHours(binHour, 0, 0, 0);
              const binKey = binTime.getTime();
              timeline[binKey] = (timeline[binKey] || 0) + value;
              if (binKey < minTime) minTime = binKey;
              if (binKey > maxTime) maxTime = binKey;
            });
          } catch (e) {
            console.error("Error processing trade for portfolio unrealized:", trade, e);
          }
        }
      });
      const labels = [];
      const dataPoints = [];
      if (minTime === Infinity || maxTime === -Infinity) return;
      for (let t = minTime; t <= maxTime; t += 4 * 60 * 60 * 1000) {
        labels.push(new Date(t).toLocaleDateString());
        dataPoints.push(timeline[t] !== undefined ? timeline[t] : 0);
      }
      const ctx = document.getElementById(canvasId).getContext('2d');
      if (window[canvasId + "Chart"]) {
        window[canvasId + "Chart"].data.labels = labels;
        window[canvasId + "Chart"].data.datasets[0].data = dataPoints;
        window[canvasId + "Chart"].update();
      } else {
        window[canvasId + "Chart"] = new Chart(ctx, {
          type: 'line',
          data: {
            labels: labels,
            datasets: [{
              label: 'Portfolio Unrealized PnL',
              data: dataPoints,
              fill: false,
              borderColor: 'rgba(153, 102, 255, 1)',
              backgroundColor: 'rgba(153, 102, 255, 0.5)',
              borderWidth: 2,
              pointRadius: 0,
              tension: 0
            }]
          },
          options: {
            scales: {
              x: { title: { display: true, text: 'Time (4h intervals)' } },
              y: { beginAtZero: true, title: { display: true, text: 'Unrealized PnL' } }
            }
          }
        });
      }
    }

    function updateEquityLineChart(data, canvasId) {
      // ... (existing code unchanged)
      const dailyProfits = {};
      data.forEach(trade => {
        let pnl = parseFloat(trade['PnL']) || 0;
        if (trade['Exit Date'] && trade['Exit Date'].trim() !== "") {
          let exitDateStr = trade['Exit Date'].trim();
          if (!exitDateStr.includes('T')) exitDateStr = exitDateStr.replace(' ', 'T');
          const exitDate = new Date(exitDateStr);
          const dateKey = exitDate.toISOString().split('T')[0];
          dailyProfits[dateKey] = (dailyProfits[dateKey] || 0) + pnl;
        }
      });
      const sortedDates = Object.keys(dailyProfits).sort();
      if (sortedDates.length === 0) return;
      const startDate = new Date(sortedDates[0]);
      const endDate = new Date(sortedDates[sortedDates.length - 1]);
      const dateLabels = [];
      const equityData = [];
      let cumulative = 0;
      let currentDate = new Date(startDate);
      while (currentDate <= endDate) {
        const dateStr = currentDate.toISOString().split('T')[0];
        const dailyPnl = dailyProfits[dateStr] || 0;
        cumulative += dailyPnl;
        dateLabels.push(dateStr);
        equityData.push(cumulative);
        currentDate.setDate(currentDate.getDate() + 1);
      }
      const ctx = document.getElementById(canvasId).getContext('2d');
      if (window[canvasId + "Chart"]) {
        window[canvasId + "Chart"].data.labels = dateLabels;
        window[canvasId + "Chart"].data.datasets[0].data = equityData;
        window[canvasId + "Chart"].update();
      } else {
        window[canvasId + "Chart"] = new Chart(ctx, {
          type: 'line',
          data: {
            labels: dateLabels,
            datasets: [{
              label: 'Equity Line (Cumulative PnL)',
              data: equityData,
              fill: false,
              borderColor: 'rgba(255, 159, 64, 1)',
              backgroundColor: 'rgba(255, 159, 64, 0.5)',
              borderWidth: 2,
              pointRadius: 0,
              tension: 0
            }]
          },
          options: {
            scales: {
              x: { title: { display: true, text: 'Date' } },
              y: { beginAtZero: false, title: { display: true, text: 'Cumulative PnL' } }
            }
          }
        });
      }
    }

    function updateFinalPnlDistributionChart(riskSize, data, canvasId) {
      // ... (existing code unchanged)
      const binEdges = [-Infinity, -10, -5, -2, -1, -0.5, 0, 0.5, 1, 2, 5, 10, 100, Infinity];
      let bins = new Array(binEdges.length - 1).fill(0);
      const labels = [];
      let qualifiedTrades = 0;
      for (let i = 0; i < binEdges.length - 1; i++) {
        if (binEdges[i] === -Infinity) {
          labels.push("< -10");
        } else if (binEdges[i+1] === Infinity) {
          labels.push("> 100");
        } else {
          labels.push(`${binEdges[i]} to ${binEdges[i+1]}`);
        }
      }
      data.forEach((trade, index) => {
        if (trade['Daily unrealized'] && trade['Daily unrealized'].trim() !== "") {
          try {
            const dailyUnrealized = JSON.parse(trade['Daily unrealized']);
            const has2RR = dailyUnrealized.some(val => parseFloat(val) >= 2 * riskSize);
            if (has2RR) {
              qualifiedTrades++;
              let pnl = parseFloat(trade['PnL']) || 0;
              let normalizedPnl = pnl / riskSize;
              for (let i = 0; i < bins.length; i++) {
                if (normalizedPnl >= binEdges[i] && normalizedPnl < binEdges[i+1]) {
                  bins[i]++;
                  break;
                }
              }
            }
          } catch(e) {
            console.error("Error parsing Daily unrealized for trade index", index, e);
          }
        }
      });
      const percentages = bins.map(count => (qualifiedTrades ? (count / qualifiedTrades) * 100 : 0));
      const cumulative = [];
      let runningTotal = 0;
      for (let i = 0; i < percentages.length; i++) {
        runningTotal += percentages[i];
        cumulative.push(runningTotal);
      }
      const multilineLabels = labels.map((lab, i) => [lab, bins[i] + " T"]);
      const ctx = document.getElementById(canvasId).getContext('2d');
      if (window[canvasId + "Chart"]) {
        window[canvasId + "Chart"].data.labels = multilineLabels;
        window[canvasId + "Chart"].data.datasets[0].data = percentages;
        window[canvasId + "Chart"].data.datasets[1].data = cumulative;
        window[canvasId + "Chart"].update();
      } else {
        window[canvasId + "Chart"] = new Chart(ctx, {
          type: 'bar',
          data: {
            labels: multilineLabels,
            datasets: [
              {
                label: 'Percentage of Qualified Trades',
                data: percentages,
                backgroundColor: 'rgba(0, 200, 83, 0.6)',
                borderColor: 'rgba(0, 200, 83, 1)',
                borderWidth: 1,
                yAxisID: 'yRight'
              },
              {
                label: 'Cumulative Percentage',
                type: 'line',
                data: cumulative,
                borderColor: 'rgba(0, 0, 0, 1)',
                backgroundColor: 'rgba(0, 0, 0, 1)',
                borderWidth: 2,
                fill: false,
                yAxisID: 'yLeft',
                tension: 0,
                pointStyle: 'circle',
                pointRadius: 4,
                pointHoverRadius: 6
              }
            ]
          },
          options: {
            scales: {
              x: { title: { display: true, text: 'Final PnL in RR Terms' } },
              yLeft: { position: 'left', beginAtZero: true, title: { display: true, text: 'Cumulative Percentage (%)' } },
              yRight: { position: 'right', beginAtZero: true, title: { display: true, text: 'Percentage (%)' }, grid: { drawOnChartArea: false } }
            }
          }
        });
      }
    }

    function updateFinalPnlDistributionChart5(riskSize, data, canvasId) {
      // ... (existing code unchanged)
      const binEdges = [-Infinity, -10, -5, -2, -1, -0.5, 0, 0.5, 1, 2, 5, 10, 100, Infinity];
      let bins = new Array(binEdges.length - 1).fill(0);
      const labels = [];
      let qualifiedTrades = 0;
      for (let i = 0; i < binEdges.length - 1; i++) {
        if (binEdges[i] === -Infinity) {
          labels.push("< -10");
        } else if (binEdges[i+1] === Infinity) {
          labels.push("> 100");
        } else {
          labels.push(`${binEdges[i]} to ${binEdges[i+1]}`);
        }
      }
      data.forEach((trade, index) => {
        if (trade['Daily unrealized'] && trade['Daily unrealized'].trim() !== "") {
          try {
            const dailyUnrealized = JSON.parse(trade['Daily unrealized']);
            const has5RR = dailyUnrealized.some(val => parseFloat(val) >= 5 * riskSize);
            if (has5RR) {
              qualifiedTrades++;
              let pnl = parseFloat(trade['PnL']) || 0;
              let normalizedPnl = pnl / riskSize;
              for (let i = 0; i < bins.length; i++) {
                if (normalizedPnl >= binEdges[i] && normalizedPnl < binEdges[i+1]) {
                  bins[i]++;
                  break;
                }
              }
            }
          } catch(e) {
            console.error("Error parsing Daily unrealized for trade index", index, e);
          }
        }
      });
      const percentages = bins.map(count => (qualifiedTrades ? (count / qualifiedTrades) * 100 : 0));
      const cumulative = [];
      let runningTotal = 0;
      for (let i = 0; i < percentages.length; i++) {
        runningTotal += percentages[i];
        cumulative.push(runningTotal);
      }
      const multilineLabels = labels.map((lab, i) => [lab, bins[i] + " T"]);
      const ctx = document.getElementById(canvasId).getContext('2d');
      if (window[canvasId + "Chart"]) {
        window[canvasId + "Chart"].data.labels = multilineLabels;
        window[canvasId + "Chart"].data.datasets[0].data = percentages;
        window[canvasId + "Chart"].data.datasets[1].data = cumulative;
        window[canvasId + "Chart"].update();
      } else {
        window[canvasId + "Chart"] = new Chart(ctx, {
          type: 'bar',
          data: {
            labels: multilineLabels,
            datasets: [
              {
                label: 'Percentage of Qualified Trades',
                data: percentages,
                backgroundColor: 'rgba(66, 165, 245, 0.6)',
                borderColor: 'rgba(66, 165, 245, 1)',
                borderWidth: 1,
                yAxisID: 'yRight'
              },
              {
                label: 'Cumulative Percentage',
                type: 'line',
                data: cumulative,
                borderColor: 'rgba(0, 0, 0, 1)',
                backgroundColor: 'rgba(0, 0, 0, 1)',
                borderWidth: 2,
                fill: false,
                yAxisID: 'yLeft',
                tension: 0,
                pointStyle: 'circle',
                pointRadius: 4,
                pointHoverRadius: 6
              }
            ]
          },
          options: {
            scales: {
              x: { title: { display: true, text: 'Final PnL in RR Terms' } },
              yLeft: { position: 'left', beginAtZero: true, title: { display: true, text: 'Cumulative Percentage (%)' } },
              yRight: { position: 'right', beginAtZero: true, title: { display: true, text: 'Percentage (%)' }, grid: { drawOnChartArea: false } }
            }
          }
        });
      }
    }

    function updateFinalPnlDistributionChart10(riskSize, data, canvasId) {
      // ... (existing code unchanged)
      const binEdges = [-Infinity, -10, -5, -2, -1, -0.5, 0, 0.5, 1, 2, 5, 10, 100, Infinity];
      let bins = new Array(binEdges.length - 1).fill(0);
      const labels = [];
      let qualifiedTrades = 0;
      for (let i = 0; i < binEdges.length - 1; i++) {
        if (binEdges[i] === -Infinity) {
          labels.push("< -10");
        } else if (binEdges[i+1] === Infinity) {
          labels.push("> 100");
        } else {
          labels.push(`${binEdges[i]} to ${binEdges[i+1]}`);
        }
      }
      data.forEach((trade, index) => {
        if (trade['Daily unrealized'] && trade['Daily unrealized'].trim() !== "") {
          try {
            const dailyUnrealized = JSON.parse(trade['Daily unrealized']);
            const has10RR = dailyUnrealized.some(val => parseFloat(val) >= 10 * riskSize);
            if (has10RR) {
              qualifiedTrades++;
              let pnl = parseFloat(trade['PnL']) || 0;
              let normalizedPnl = pnl / riskSize;
              for (let i = 0; i < bins.length; i++) {
                if (normalizedPnl >= binEdges[i] && normalizedPnl < binEdges[i+1]) {
                  bins[i]++;
                  break;
                }
              }
            }
          } catch(e) {
            console.error("Error parsing Daily unrealized for trade index", index, e);
          }
        }
      });
      const percentages = bins.map(count => (qualifiedTrades ? (count / qualifiedTrades) * 100 : 0));
      const cumulative = [];
      let runningTotal = 0;
      for (let i = 0; i < percentages.length; i++) {
        runningTotal += percentages[i];
        cumulative.push(runningTotal);
      }
      const multilineLabels = labels.map((lab, i) => [lab, bins[i] + " T"]);
      const ctx = document.getElementById(canvasId).getContext('2d');
      if (window[canvasId + "Chart"]) {
        window[canvasId + "Chart"].data.labels = multilineLabels;
        window[canvasId + "Chart"].data.datasets[0].data = percentages;
        window[canvasId + "Chart"].data.datasets[1].data = cumulative;
        window[canvasId + "Chart"].update();
      } else {
        window[canvasId + "Chart"] = new Chart(ctx, {
          type: 'bar',
          data: {
            labels: multilineLabels,
            datasets: [
              {
                label: 'Percentage of Qualified Trades',
                data: percentages,
                backgroundColor: 'rgba(255, 202, 40, 0.6)',
                borderColor: 'rgba(255, 202, 40, 1)',
                borderWidth: 1,
                yAxisID: 'y'
              },
              {
                label: 'Cumulative Percentage',
                type: 'line',
                data: cumulative,
                borderColor: 'rgba(0, 0, 0, 1)',
                backgroundColor: 'rgba(0, 0, 0, 1)',
                borderWidth: 2,
                fill: false,
                yAxisID: 'y2',
                tension: 0,
                pointStyle: 'circle',
                pointRadius: 4,
                pointHoverRadius: 6
              }
            ]
          },
          options: {
            scales: {
              x: { title: { display: true, text: 'Final PnL in RR Terms' } },
              yLeft: { position: 'left', beginAtZero: true, title: { display: true, text: 'Cumulative Percentage (%)' } },
              yRight: { position: 'right', beginAtZero: true, title: { display: true, text: 'Percentage (%)' }, grid: { drawOnChartArea: false } }
            }
          }
        });
      }
    }

    function updateDurationToMaxDistributionChart(data, canvasId) {
      // ... (existing code unchanged)
      let durations = [];
      data.forEach(trade => {
        if (trade['Daily unrealized'] && trade['Daily unrealized'].trim() !== "" &&
            trade['Entry Dates'] && trade['Entry Dates'].trim() !== "") {
          try {
            const dailyUnrealized = JSON.parse(trade['Daily unrealized']);
            if (Array.isArray(dailyUnrealized) && dailyUnrealized.length > 0) {
              let maxIndex = 0;
              let maxVal = parseFloat(dailyUnrealized[0]);
              for (let i = 1; i < dailyUnrealized.length; i++) {
                const currentVal = parseFloat(dailyUnrealized[i]);
                if (!isNaN(currentVal) && currentVal > maxVal) {
                  maxVal = currentVal;
                  maxIndex = i;
                }
              }
              let duration = (maxIndex * 4) / 24;
              duration = Math.round(duration);
              if (duration >= 1) {
                durations.push(duration);
              }
            }
          } catch (e) {
            console.error("Error computing duration to max uPnL for trade", trade, e);
          }
        }
      });
      const binEdges = [1, 3, 5, 7, 9, 11];
      const labels = ["1–2", "3–4", "5–6", "7–8", "9–10", "10+"];
      let bins = new Array(labels.length).fill(0);
      durations.forEach(d => {
        let placed = false;
        for (let i = 0; i < binEdges.length - 1; i++) {
          if (d >= binEdges[i] && d < binEdges[i + 1]) {
            bins[i]++;
            placed = true;
            break;
          }
        }
        if (!placed) {
          bins[bins.length - 1]++;
        }
      });
      const total = durations.length;
      const percentages = bins.map(count => total ? (count / total) * 100 : 0);
      let cumulative = [];
      let runningSum = 0;
      percentages.forEach(p => {
        runningSum += p;
        cumulative.push(runningSum);
      });
      const ctx = document.getElementById(canvasId).getContext('2d');
      if (window[canvasId + "Chart"]) {
        window[canvasId + "Chart"].data.labels = labels;
        window[canvasId + "Chart"].data.datasets[0].data = percentages;
        window[canvasId + "Chart"].data.datasets[1].data = cumulative;
        window[canvasId + "Chart"].update();
      } else {
        window[canvasId + "Chart"] = new Chart(ctx, {
          type: 'bar',
          data: {
            labels: labels,
            datasets: [
              {
                label: 'Percentage of Trades',
                data: percentages,
                backgroundColor: 'rgba(54, 162, 235, 0.6)',
                borderColor: 'rgba(54, 162, 235, 1)',
                borderWidth: 1,
                yAxisID: 'y'
              },
              {
                label: 'Cumulative Percentage',
                type: 'line',
                data: cumulative,
                borderColor: 'rgba(0, 0, 0, 1)',
                backgroundColor: 'rgba(0, 0, 0, 1)',
                borderWidth: 2,
                fill: false,
                yAxisID: 'y2',
                tension: 0,
                pointStyle: 'circle',
                pointRadius: 4,
                pointHoverRadius: 6
              }
            ]
          },
          options: {
            scales: {
              x: {
                title: { display: true, text: 'Duration to Max uPnL (days)' }
              },
              y: {
                beginAtZero: true,
                title: { display: true, text: 'Percentage of Trades (%)' }
              },
              y2: {
                position: 'right',
                grid: { drawOnChartArea: false },
                beginAtZero: true,
                title: { display: true, text: 'Cumulative Percentage (%)' }
              }
            }
          }
        });
      }
    }

    function updateDurationToMaxDistributionChartAbove5(data, canvasId) {
      // ... (existing code unchanged)
      let durations = [];
      const riskSizeInput = parseFloat(document.getElementById('riskSize').value) || 55.55;
      data.forEach(trade => {
        if (trade['Daily unrealized'] && trade['Daily unrealized'].trim() !== "" &&
            trade['Entry Dates'] && trade['Entry Dates'].trim() !== "") {
          try {
            const dailyUnrealized = JSON.parse(trade['Daily unrealized']);
            if (Array.isArray(dailyUnrealized) && dailyUnrealized.length > 0) {
              let maxIndex = 0;
              let maxVal = parseFloat(dailyUnrealized[0]);
              for (let i = 1; i < dailyUnrealized.length; i++) {
                const currentVal = parseFloat(dailyUnrealized[i]);
                if (!isNaN(currentVal) && currentVal > maxVal) {
                  maxVal = currentVal;
                  maxIndex = i;
                }
              }
              const normalizedMax = maxVal / riskSizeInput;
              if (normalizedMax > 5) {
                let duration = (maxIndex * 4) / 24;
                duration = Math.round(duration);
                if (duration >= 1) {
                  durations.push(duration);
                }
              }
            }
          } catch (e) {
            console.error("Error computing duration to max uPnL for trade", trade, e);
          }
        }
      });
      const binEdges = [1, 3, 5, 7, 9, 11];
      const labels = ["1–2", "3–4", "5–6", "7–8", "9–10", "10+"];
      let bins = new Array(labels.length).fill(0);
      durations.forEach(d => {
        let placed = false;
        for (let i = 0; i < binEdges.length - 1; i++) {
          if (d >= binEdges[i] && d < binEdges[i + 1]) {
            bins[i]++;
            placed = true;
            break;
          }
        }
        if (!placed) {
          bins[bins.length - 1]++;
        }
      });
      const total = durations.length;
      const percentages = bins.map(count => total ? (count / total) * 100 : 0);
      let cumulative = [];
      let runningSum = 0;
      percentages.forEach(p => {
        runningSum += p;
        cumulative.push(runningSum);
      });
      const ctx = document.getElementById(canvasId).getContext('2d');
      if (window[canvasId + "Chart"]) {
        window[canvasId + "Chart"].data.labels = labels;
        window[canvasId + "Chart"].data.datasets[0].data = percentages;
        window[canvasId + "Chart"].data.datasets[1].data = cumulative;
        window[canvasId + "Chart"].update();
      } else {
        window[canvasId + "Chart"] = new Chart(ctx, {
          type: 'bar',
          data: {
            labels: labels,
            datasets: [
              {
                label: 'Percentage of Trades',
                data: percentages,
                backgroundColor: 'rgba(66, 165, 245, 0.6)',
                borderColor: 'rgba(66, 165, 245, 1)',
                borderWidth: 1,
                yAxisID: 'y'
              },
              {
                label: 'Cumulative Percentage',
                type: 'line',
                data: cumulative,
                borderColor: 'rgba(0, 0, 0, 1)',
                backgroundColor: 'rgba(0, 0, 0, 1)',
                borderWidth: 2,
                fill: false,
                yAxisID: 'y2',
                tension: 0,
                pointStyle: 'circle',
                pointRadius: 4,
                pointHoverRadius: 6
              }
            ]
          },
          options: {
            scales: {
              x: {
                title: { display: true, text: 'Duration to Max uPnL (days)' }
              },
              y: {
                beginAtZero: true,
                title: { display: true, text: 'Percentage of Trades (%)' }
              },
              y2: {
                position: 'right',
                grid: { drawOnChartArea: false },
                beginAtZero: true,
                title: { display: true, text: 'Cumulative Percentage (%)' }
              }
            }
          }
        });
      }
    }

    function updateDurationToMaxDistributionChartAbove10(data, canvasId) {
      let durations = [];
      const riskSizeInput = parseFloat(document.getElementById('riskSize').value) || 55.55;
      data.forEach(trade => {
        if (trade['Daily unrealized'] && trade['Daily unrealized'].trim() !== "" &&
            trade['Entry Dates'] && trade['Entry Dates'].trim() !== "") {
          try {
            const dailyUnrealized = JSON.parse(trade['Daily unrealized']);
            if (Array.isArray(dailyUnrealized) && dailyUnrealized.length > 0) {
              let maxIndex = 0;
              let maxVal = parseFloat(dailyUnrealized[0]);
              for (let i = 1; i < dailyUnrealized.length; i++) {
                const currentVal = parseFloat(dailyUnrealized[i]);
                if (!isNaN(currentVal) && currentVal > maxVal) {
                  maxVal = currentVal;
                  maxIndex = i;
                }
              }
              const normalizedMax = maxVal / riskSizeInput;
              if (normalizedMax > 10) {
                let duration = (maxIndex * 4) / 24;
                duration = Math.round(duration);
                if (duration >= 1) {
                  durations.push(duration);
                }
              }
            }
          } catch (e) {
            console.error("Error computing duration to max uPnL for trade", trade, e);
          }
        }
      });
      const binEdges = [1, 3, 5, 7, 9, 11];
      const labels = ["1–2", "3–4", "5–6", "7–8", "9–10", "10+"];
      let bins = new Array(labels.length).fill(0);
      durations.forEach(d => {
        let placed = false;
        for (let i = 0; i < binEdges.length - 1; i++) {
          if (d >= binEdges[i] && d < binEdges[i + 1]) {
            bins[i]++;
            placed = true;
            break;
          }
        }
        if (!placed) {
          bins[bins.length - 1]++;
        }
      });
      const total = durations.length;
      const percentages = bins.map(count => total ? (count / total) * 100 : 0);
      let cumulative = [];
      let runningSum = 0;
      percentages.forEach(p => {
        runningSum += p;
        cumulative.push(runningSum);
      });
      const ctx = document.getElementById(canvasId).getContext('2d');
      if (window[canvasId + "Chart"]) {
        window[canvasId + "Chart"].data.labels = labels;
        window[canvasId + "Chart"].data.datasets[0].data = percentages;
        window[canvasId + "Chart"].data.datasets[1].data = cumulative;
        window[canvasId + "Chart"].update();
      } else {
        window[canvasId + "Chart"] = new Chart(ctx, {
          type: 'bar',
          data: {
            labels: labels,
            datasets: [
              {
                label: 'Percentage of Trades',
                data: percentages,
                backgroundColor: 'rgba(255, 202, 40, 0.6)',
                borderColor: 'rgba(255, 202, 40, 1)',
                borderWidth: 1,
                // Use the same axis key as defined in options
                yAxisID: 'yRight'
              },
              {
                label: 'Cumulative Percentage',
                type: 'line',
                data: cumulative,
                borderColor: 'rgba(0, 0, 0, 1)',
                backgroundColor: 'rgba(0, 0, 0, 1)',
                borderWidth: 2,
                fill: false,
                // Use the same axis key as defined in options
                yAxisID: 'yLeft',
                tension: 0,
                pointStyle: 'circle',
                pointRadius: 4,
                pointHoverRadius: 6
              }
            ]
          },
          options: {
            scales: {
              x: {
                title: { display: true, text: 'Duration to Max uPnL (days)' }
              },
              yLeft: {
                position: 'left',
                beginAtZero: true,
                title: { display: true, text: 'Cumulative Percentage (%)' }
              },
              yRight: {
                position: 'right',
                beginAtZero: true,
                title: { display: true, text: 'Percentage (%)' },
                grid: { drawOnChartArea: false }
              }
            }
          }
        });
      }
    }

    /*****************************************
     * Process CSV & Display Summary Metrics *
     *****************************************/
    function processCSV(data) {
      // ... (existing code unchanged)
      let totalTrades = data.length;
      let netProfit = 0, positiveTrades = 0;
      let largestSingleTradeProfit = -Infinity, largestSingleTradeLoss = Infinity;
      const dailyProfits = {};
      let totalDuration = 0, countDuration = 0;
      let largestUnrealizedProfit = -Infinity;
      data.forEach(trade => {
        const pnl = parseFloat(trade['PnL']) || 0;
        netProfit += pnl;
        if (pnl > 0) positiveTrades++;
        if (pnl > largestSingleTradeProfit) largestSingleTradeProfit = pnl;
        if (pnl < largestSingleTradeLoss) largestSingleTradeLoss = pnl;
        let exitDateStr = (trade['Exit Date'] || "").trim();
        if (!exitDateStr.includes('T')) exitDateStr = exitDateStr.replace(' ', 'T');
        const exitDate = new Date(exitDateStr);
        const dateKey = exitDate.toISOString().split('T')[0];
        dailyProfits[dateKey] = (dailyProfits[dateKey] || 0) + pnl;
        if (trade['Entry Dates'] && trade['Entry Dates'].trim() !== "") {
          try {
            let entryDatesStr = trade['Entry Dates'].replace(/'/g, '"');
            let entryDatesArray = JSON.parse(entryDatesStr);
            if (Array.isArray(entryDatesArray) && entryDatesArray.length > 0) {
              let firstEntryDate = entryDatesArray[0].trim();
              if (!firstEntryDate.includes('T')) firstEntryDate = firstEntryDate.replace(' ', 'T');
              let startDate = new Date(firstEntryDate);
              let duration = Math.round((exitDate - startDate) / (1000 * 60 * 60 * 24));
              if (!isNaN(duration)) {
                totalDuration += duration;
                countDuration++;
              }
            }
          } catch (e) {
            console.error("Error computing duration for trade", trade, e);
          }
        }
        if (trade['Daily unrealized'] && trade['Daily unrealized'].trim() !== "") {
          try {
            const dailyUnrealized = JSON.parse(trade['Daily unrealized']);
            if (Array.isArray(dailyUnrealized) && dailyUnrealized.length > 0) {
              const dailyValues = dailyUnrealized
                .map(val => parseFloat(val))
                .filter(val => !isNaN(val));
              if (dailyValues.length > 0) {
                const tradeMax = Math.max(...dailyValues);
                if (tradeMax > largestUnrealizedProfit) {
                  largestUnrealizedProfit = tradeMax;
                }
              }
            }
          } catch (e) {
            console.error("Error parsing Daily unrealized for trade", trade, e);
          }
        }
      });
      const successRate = (positiveTrades / totalTrades) * 100;
      const dateKeys = Object.keys(dailyProfits).sort();
      let firstDate = new Date(dateKeys[0]);
      let lastDate = new Date(dateKeys[dateKeys.length - 1]);
      const msInDay = 1000 * 60 * 60 * 24;
      const fullDaysCount = Math.round((lastDate - firstDate) / msInDay) + 1;
      const dailyAvgProfit = netProfit / fullDaysCount;
      const sortedDates = dateKeys;
      let cumulative = 0;
      const equityCurve = sortedDates.map(date => {
        cumulative += dailyProfits[date];
        return { date: date, cumulative: cumulative };
      });
      let peak = -Infinity, maxDrawdown = 0, dateOfMaxDD = '';
      equityCurve.forEach(point => {
        if (point.cumulative > peak) peak = point.cumulative;
        const drawdown = peak - point.cumulative;
        if (drawdown > maxDrawdown) {
          maxDrawdown = drawdown;
          dateOfMaxDD = point.date;
        }
      });
      const maxDrawdownPercent = peak ? (maxDrawdown / peak) * 100 : 0;
      let oneDayMaxProfit = -Infinity, oneDayMaxLoss = Infinity, dateOfMaxLoss = '';
      for (const [date, profit] of Object.entries(dailyProfits)) {
        if (profit > oneDayMaxProfit) oneDayMaxProfit = profit;
        if (profit < oneDayMaxLoss) {
          oneDayMaxLoss = profit;
          dateOfMaxLoss = date;
        }
      }
      const profitToDrawdown = maxDrawdown !== 0 ? netProfit / maxDrawdown : 'N/A';
      const averageTradeDuration = countDuration > 0 ? totalDuration / countDuration : 0;
      return {
        totalTrades,
        netProfit,
        dailyAvgProfit,
        successRate,
        maxDrawdownAbsolute: maxDrawdown,
        maxDrawdownPercent,
        dateOfMaxDD,
        oneDayMaxProfit,
        oneDayMaxLoss,
        dateOfMaxLoss,
        profitToDrawdown,
        largestSingleTradeProfit,
        largestSingleTradeLoss,
        averageTradeDuration,
        largestUnrealizedProfit: largestUnrealizedProfit
      };
    }

    function displayChartMetrics(data, containerId) {
      // ... (existing code unchanged)
      let totalTrades = data.length;
      let sumEfficiency = 0, countEfficiency = 0;
      let sumUpnlPeaks = 0;
      let sumDurationToMax = 0, countDurationToMax = 0;
      let sumDurationToMaxAbove5 = 0, countDurationToMaxAbove5 = 0;
      let sumDurationToMaxAbove10 = 0, countDurationToMaxAbove10 = 0;
      const riskSizeInput = parseFloat(document.getElementById('riskSize').value) || 55.55;
      data.forEach(trade => {
        const pnl = parseFloat(trade['PnL']) || 0;
        if (pnl > 0 && trade['Daily unrealized'] && trade['Daily unrealized'].trim() !== "") {
          try {
            const rawArray = JSON.parse(trade['Daily unrealized']);
            if (Array.isArray(rawArray) && rawArray.length > 0) {
              const numericValues = rawArray.map(val => parseFloat(val)).filter(val => !isNaN(val));
              if (numericValues.length > 0) {
                const maxUpnl = Math.max(...numericValues);
                if (maxUpnl !== 0) {
                  const efficiency = (pnl / maxUpnl) * 100;
                  sumEfficiency += efficiency;
                  countEfficiency++;
                }
              }
            }
          } catch (e) {
            console.error("Error parsing Daily unrealized for PnL Efficiency", trade, e);
          }
        }
        if (trade['Daily unrealized'] && trade['Daily unrealized'].trim() !== "") {
          try {
            const rawArray = JSON.parse(trade['Daily unrealized']);
            if (Array.isArray(rawArray) && rawArray.length > 0) {
              const numericValues = rawArray.map(val => parseFloat(val)).filter(val => !isNaN(val));
              if (numericValues.length > 0) {
                const minVal = Math.min(...numericValues);
                const maxVal = Math.max(...numericValues);
                if (minVal < 500 && maxVal >= 3000) {
                  sumUpnlPeaks += maxVal;
                }
              }
            }
          } catch (e) {
            console.error("Error parsing Daily unrealized for uPnL Peaks", trade, e);
          }
        }
        if (trade['Daily unrealized'] && trade['Daily unrealized'].trim() !== "" &&
            trade['Entry Dates'] && trade['Entry Dates'].trim() !== "") {
          try {
            const dailyUnrealized = JSON.parse(trade['Daily unrealized']);
            if (Array.isArray(dailyUnrealized) && dailyUnrealized.length > 0) {
              let maxIndex = 0;
              let maxVal = parseFloat(dailyUnrealized[0]);
              for (let i = 1; i < dailyUnrealized.length; i++) {
                const currentVal = parseFloat(dailyUnrealized[i]);
                if (!isNaN(currentVal) && currentVal > maxVal) {
                  maxVal = currentVal;
                  maxIndex = i;
                }
              }
              const durationToMaxInDays = (maxIndex * 4) / 24;
              sumDurationToMax += durationToMaxInDays;
              countDurationToMax++;
              const normalizedMaxUpnl = maxVal / riskSizeInput;
              if (normalizedMaxUpnl > 5) {
                sumDurationToMaxAbove5 += durationToMaxInDays;
                countDurationToMaxAbove5++;
              }
              if (normalizedMaxUpnl > 10) {
                sumDurationToMaxAbove10 += durationToMaxInDays;
                countDurationToMaxAbove10++;
              }
            }
          } catch (e) {
            console.error("Error computing duration to max uPnL", trade, e);
          }
        }
      });
      const avgEfficiency = countEfficiency ? (sumEfficiency / countEfficiency) : 0;
      const avgDurationToMax = countDurationToMax ? (sumDurationToMax / countDurationToMax) : 0;
      const avgDurationToMaxAbove5 = countDurationToMaxAbove5 ? (sumDurationToMaxAbove5 / countDurationToMaxAbove5) : 0;
      const avgDurationToMaxAbove10 = countDurationToMaxAbove10 ? (sumDurationToMaxAbove10 / countDurationToMaxAbove10) : 0;
      const extraMetrics = processCSV(data);
      document.getElementById(containerId).innerHTML = `
        <div class="summary-item"><strong>Total Trades</strong> ${extraMetrics.totalTrades}</div>
        <div class="summary-item"><strong>Net Profit</strong> ${extraMetrics.netProfit.toFixed(2)}</div>
        <div class="summary-item"><strong>Daily Avg Profit</strong> ${extraMetrics.dailyAvgProfit.toFixed(2)}</div>
        <div class="summary-item"><strong>Success Rate</strong> ${extraMetrics.successRate.toFixed(2)}%</div>
        <div class="summary-item"><strong>Max DD (Absolute)</strong> ${extraMetrics.maxDrawdownAbsolute.toFixed(2)}</div>
        <div class="summary-item"><strong>Max DD (%)</strong> ${extraMetrics.maxDrawdownPercent.toFixed(2)}%</div>
        <div class="summary-item"><strong>Date of Max DD</strong> ${extraMetrics.dateOfMaxDD}</div>
        <div class="summary-item"><strong>One Day Max Profit</strong> ${extraMetrics.oneDayMaxProfit.toFixed(2)}</div>
        <div class="summary-item"><strong>One Day Max Loss</strong> ${extraMetrics.oneDayMaxLoss.toFixed(2)}</div>
        <div class="summary-item"><strong>Date of Max Loss</strong> ${extraMetrics.dateOfMaxLoss}</div>
        <div class="summary-item"><strong>Profit/Max DD</strong> ${extraMetrics.profitToDrawdown === 'N/A' ? 'N/A' : extraMetrics.profitToDrawdown.toFixed(2)}</div>
        <div class="summary-item"><strong>Largest Single Trade Profit</strong> ${extraMetrics.largestSingleTradeProfit.toFixed(2)}</div>
        <div class="summary-item"><strong>Largest Single Trade Loss</strong> ${extraMetrics.largestSingleTradeLoss.toFixed(2)}</div>
        <div class="summary-item"><strong>Average Trade Duration</strong> ${extraMetrics.averageTradeDuration.toFixed(2)} days</div>
        <div class="summary-item"><strong>Largest Single Unrealized Profit</strong> ${extraMetrics.largestUnrealizedProfit.toFixed(2)}</div>
        <div class="summary-item"><strong>PnL Efficiency</strong> ${avgEfficiency.toFixed(2)}%</div>
        <div class="summary-item"><strong>Sum uPnL Peaks</strong> ${sumUpnlPeaks.toFixed(2)}</div>
        <div class="summary-item"><strong>Avg Duration to Max uPnL</strong> ${avgDurationToMax.toFixed(2)} days</div>
        <div class="summary-item"><strong>Avg Duration to Max uPnL (&gt;5 RR)</strong> ${avgDurationToMaxAbove5.toFixed(2)} days</div>
        <div class="summary-item"><strong>Avg Duration to Max uPnL (&gt;10 RR)</strong> ${avgDurationToMaxAbove10.toFixed(2)} days</div>
      `;
    }

    /*******************************************
     * Functions to load CSV files & update charts
     *******************************************/
    // This function creates the HTML structure for a given file.
    // Note: We wrap each section in an extra div with an id to allow us to hide/show it.
    function createFileContainer(prefix) {
      const container = document.createElement('div');
      container.classList.add('file-container');
      container.innerHTML = `
        <div id="${prefix}_all_section">
          <h2>${prefix} Charts (All Trades)</h2>
          <div class="distribution">
            <div class="summary" id="${prefix}_all-trades-summary"></div>
            <div class="chartsContainer">
              <div>
                <h3>Unrealized Profit Distribution</h3>
                <canvas id="${prefix}_distributionChart_all" width="300" height="400"></canvas>
              </div>
              <div>
                <h3>PnL Distribution</h3>
                <canvas id="${prefix}_pnlDistributionChart_all" width="300" height="400"></canvas>
              </div>
              <div>
                <h3>Portfolio Unrealized PnL Over Time</h3>
                <canvas id="${prefix}_portfolioUnrealizedChart_all" width="600" height="400"></canvas>
              </div>
              <div>
                <h3>Equity Line (Cumulative PnL)</h3>
                <canvas id="${prefix}_equityLineChart_all" width="300" height="400"></canvas>
              </div>
              <div>
                <h3>PnL Distribution Trades &gt;2 RR</h3>
                <canvas id="${prefix}_finalPnlDistributionChart_all" width="600" height="400"></canvas>
              </div>
              <div>
                <h3>PnL Distribution Trades &gt;5 RR</h3>
                <canvas id="${prefix}_finalPnlDistributionChart5_all" width="600" height="400"></canvas>
              </div>
              <div>
                <h3>PnL Distribution Trades &gt;10 RR</h3>
                <canvas id="${prefix}_finalPnlDistributionChart10_all" width="600" height="400"></canvas>
              </div>
              <div>
                <h3>Duration to Max uPnL (Days)</h3>
                <canvas id="${prefix}_durationToMaxDistributionChart_all" width="300" height="400"></canvas>
              </div>
              <div>
                <h3>Max uPnL Distribution (&gt; 5 RR)</h3>
                <canvas id="${prefix}_durationToMaxDistributionChartAbove5_all" width="300" height="400"></canvas>
              </div>
              <div>
                <h3>Max uPnL Distribution (&gt; 10 RR)</h3>
                <canvas id="${prefix}_durationToMaxDistributionChartAbove10_all" width="300" height="400"></canvas>
              </div>
            </div>
          </div>
        </div>

        <div id="${prefix}_long_section">
          <h2>${prefix} Long Trades Charts</h2>
          <div class="distribution">
            <div class="summary" id="${prefix}_long-trades-summary"></div>
            <div class="chartsContainer">
              <div>
                <h3>Unrealized Profit Distribution (Long)</h3>
                <canvas id="${prefix}_distributionChart_long" width="300" height="400"></canvas>
              </div>
              <div>
                <h3>PnL Distribution (Long)</h3>
                <canvas id="${prefix}_pnlDistributionChart_long" width="300" height="400"></canvas>
              </div>
              <div>
                <h3>Portfolio Unrealized PnL Over Time (Long)</h3>
                <canvas id="${prefix}_portfolioUnrealizedChart_long" width="600" height="400"></canvas>
              </div>
              <div>
                <h3>Equity Line (Long Trades)</h3>
                <canvas id="${prefix}_equityLineChart_long" width="300" height="400"></canvas>
              </div>
              <div>
                <h3>PnL Distribution Trades &gt;2 RR (Long)</h3>
                <canvas id="${prefix}_finalPnlDistributionChart_long" width="600" height="400"></canvas>
              </div>
              <div>
                <h3>PnL Distribution Trades &gt;5 RR (Long)</h3>
                <canvas id="${prefix}_finalPnlDistributionChart5_long" width="600" height="400"></canvas>
              </div>
              <div>
                <h3>PnL Distribution Trades &gt;10 RR (Long)</h3>
                <canvas id="${prefix}_finalPnlDistributionChart10_long" width="600" height="400"></canvas>
              </div>
              <div>
                <h3>Duration to Max uPnL (Days)</h3>
                <canvas id="${prefix}_durationToMaxDistributionChart_long" width="300" height="400"></canvas>
              </div>
              <div>
                <h3>Duration Max uPnL Distribution (&gt; 5 RR)</h3>
                <canvas id="${prefix}_durationToMaxDistributionChartAbove5_long" width="300" height="400"></canvas>
              </div>
              <div>
                <h3>Duration Max uPnL Distribution (&gt; 10 RR)</h3>
                <canvas id="${prefix}_durationToMaxDistributionChartAbove10_long" width="300" height="400"></canvas>
              </div>
            </div>
          </div>
        </div>

        <div id="${prefix}_short_section">
          <h2>${prefix} Short Trades Charts</h2>
          <div class="distribution">
            <div class="summary" id="${prefix}_short-trades-summary"></div>
            <div class="chartsContainer">
              <div>
                <h3>Unrealized Profit Distribution (Short)</h3>
                <canvas id="${prefix}_distributionChart_short" width="300" height="400"></canvas>
              </div>
              <div>
                <h3>PnL Distribution (Short)</h3>
                <canvas id="${prefix}_pnlDistributionChart_short" width="300" height="400"></canvas>
              </div>
              <div>
                <h3>Portfolio Unrealized PnL Over Time (Short)</h3>
                <canvas id="${prefix}_portfolioUnrealizedChart_short" width="600" height="400"></canvas>
              </div>
              <div>
                <h3>Equity Line (Short Trades)</h3>
                <canvas id="${prefix}_equityLineChart_short" width="300" height="400"></canvas>
              </div>
              <div>
                <h3>PnL Distribution Trades &gt;2 RR (Short)</h3>
                <canvas id="${prefix}_finalPnlDistributionChart_short" width="600" height="400"></canvas>
              </div>
              <div>
                <h3>PnL Distribution Trades &gt;5 RR (Short)</h3>
                <canvas id="${prefix}_finalPnlDistributionChart5_short" width="600" height="400"></canvas>
              </div>
              <div>
                <h3>PnL Distribution Trades &gt;10 RR (Short)</h3>
                <canvas id="${prefix}_finalPnlDistributionChart10_short" width="600" height="400"></canvas>
              </div>
              <div>
                <h3>Duration to Max uPnL (Days)</h3>
                <canvas id="${prefix}_durationToMaxDistributionChart_short" width="300" height="400"></canvas>
              </div>
              <div>
                <h3>Duration Max uPnL Distribution (&gt; 5 RR)</h3>
                <canvas id="${prefix}_durationToMaxDistributionChartAbove5_short" width="300" height="400"></canvas>
              </div>
              <div>
                <h3>Duration Max uPnL Distribution (&gt; 10 RR)</h3>
                <canvas id="${prefix}_durationToMaxDistributionChartAbove10_short" width="300" height="400"></canvas>
              </div>
            </div>
          </div>
        </div>
      `;
      document.getElementById('filesContainer').appendChild(container);
    }

    // This function loads a CSV file (from the data folder) and then updates the charts.
    function loadCSVForFile(filePath, prefix) {
      Papa.parse(filePath, {
        download: true,
        header: true,
        complete: function(results) {
          const data = results.data;
          if (data && data.length > 0) {
            fileDataMap[prefix] = data;
            updateChartsForFile(prefix, data);
          } else {
            console.error("CSV file " + filePath + " is empty or improperly formatted.");
          }
        },
        error: function(error) {
          console.error("Error loading CSV file:", error);
        }
      });
    }

    // Given a prefix and its data, update all charts using the functions above.
    // This function now reads the checkbox states and shows/hides sections accordingly.
    function updateChartsForFile(prefix, data) {
      const riskSize = parseFloat(document.getElementById('riskSize').value) || 55.55;
      const showAllTrades = document.getElementById('chkAllTrades').checked;
      const showLongTrades = document.getElementById('chkLongTrades').checked;
      const showShortTrades = document.getElementById('chkShortTrades').checked;

      // Show or hide the sections based on the checkboxes:
      document.getElementById(prefix + "_all_section").style.display = (showAllTrades ? "block" : "none");
      document.getElementById(prefix + "_long_section").style.display = (showLongTrades ? "block" : "none");
      document.getElementById(prefix + "_short_section").style.display = (showShortTrades ? "block" : "none");

      if(showAllTrades) {
        updateDistributionChart(riskSize, data, prefix + "_distributionChart_all");
        updatePnlDistributionChart(riskSize, data, prefix + "_pnlDistributionChart_all");
        updatePortfolioUnrealizedChart(data, prefix + "_portfolioUnrealizedChart_all");
        updateEquityLineChart(data, prefix + "_equityLineChart_all");
        updateFinalPnlDistributionChart(riskSize, data, prefix + "_finalPnlDistributionChart_all");
        updateFinalPnlDistributionChart5(riskSize, data, prefix + "_finalPnlDistributionChart5_all");
        updateFinalPnlDistributionChart10(riskSize, data, prefix + "_finalPnlDistributionChart10_all");
        updateDurationToMaxDistributionChart(data, prefix + "_durationToMaxDistributionChart_all");
        updateDurationToMaxDistributionChartAbove5(data, prefix + "_durationToMaxDistributionChartAbove5_all");
        updateDurationToMaxDistributionChartAbove10(data, prefix + "_durationToMaxDistributionChartAbove10_all");
        displayChartMetrics(data, prefix + "_all-trades-summary");
      }
      if(showLongTrades) {
        const longTrades = data.filter(trade => trade['Trade Type'] === '1');
        updateDistributionChart(riskSize, longTrades, prefix + "_distributionChart_long");
        updatePnlDistributionChart(riskSize, longTrades, prefix + "_pnlDistributionChart_long");
        updatePortfolioUnrealizedChart(longTrades, prefix + "_portfolioUnrealizedChart_long");
        updateEquityLineChart(longTrades, prefix + "_equityLineChart_long");
        updateFinalPnlDistributionChart(riskSize, longTrades, prefix + "_finalPnlDistributionChart_long");
        updateFinalPnlDistributionChart5(riskSize, longTrades, prefix + "_finalPnlDistributionChart5_long");
        updateFinalPnlDistributionChart10(riskSize, longTrades, prefix + "_finalPnlDistributionChart10_long");
        updateDurationToMaxDistributionChart(longTrades, prefix + "_durationToMaxDistributionChart_long");
        updateDurationToMaxDistributionChartAbove5(longTrades, prefix + "_durationToMaxDistributionChartAbove5_long");
        updateDurationToMaxDistributionChartAbove10(longTrades, prefix + "_durationToMaxDistributionChartAbove10_long");
        displayChartMetrics(longTrades, prefix + "_long-trades-summary");
      }
      if(showShortTrades) {
        const shortTrades = data.filter(trade => trade['Trade Type'] === '2');
        updateDistributionChart(riskSize, shortTrades, prefix + "_distributionChart_short");
        updatePnlDistributionChart(riskSize, shortTrades, prefix + "_pnlDistributionChart_short");
        updatePortfolioUnrealizedChart(shortTrades, prefix + "_portfolioUnrealizedChart_short");
        updateEquityLineChart(shortTrades, prefix + "_equityLineChart_short");
        updateFinalPnlDistributionChart(riskSize, shortTrades, prefix + "_finalPnlDistributionChart_short");
        updateFinalPnlDistributionChart5(riskSize, shortTrades, prefix + "_finalPnlDistributionChart5_short");
        updateFinalPnlDistributionChart10(riskSize, shortTrades, prefix + "_finalPnlDistributionChart10_short");
        updateDurationToMaxDistributionChart(shortTrades, prefix + "_durationToMaxDistributionChart_short");
        updateDurationToMaxDistributionChartAbove5(shortTrades, prefix + "_durationToMaxDistributionChartAbove5_short");
        updateDurationToMaxDistributionChartAbove10(shortTrades, prefix + "_durationToMaxDistributionChartAbove10_short");
        displayChartMetrics(shortTrades, prefix + "_short-trades-summary");
      }
    }

    /*********************
     * Initialization
     *********************/
    // When the "Load Files" button is clicked, read the CSV filenames from the textarea.
    document.getElementById('loadFilesButton').addEventListener('click', function() {
      // Clear any previous file containers.
      document.getElementById('filesContainer').innerHTML = "";
      // Get the list from the textarea (split by newline and trim each entry).
      const rawList = document.getElementById('csvFilesList').value;
      const csvFiles = rawList.split(/\n/).map(f => f.trim()).filter(f => f.length > 0);
      // For each filename, create a container and load the CSV file (assuming they are in the "data" folder).
      csvFiles.forEach(filename => {
        const prefix = filename.replace(/\.csv$/i, "");
        createFileContainer(prefix);
        loadCSVForFile("data/" + filename, prefix);
      });
    });

    // When the risk size input changes, update the charts for every loaded file.
    document.getElementById('riskSize').addEventListener('change', function() {
      const newRiskSize = parseFloat(this.value) || 55.55;
      for (const prefix in fileDataMap) {
        if (fileDataMap.hasOwnProperty(prefix)) {
          updateChartsForFile(prefix, fileDataMap[prefix]);
        }
      }
    });

    // When any of the section option checkboxes change, update all file charts accordingly.
    document.getElementById('chkAllTrades').addEventListener('change', function() {
      for (const prefix in fileDataMap) {
        if (fileDataMap.hasOwnProperty(prefix)) {
          updateChartsForFile(prefix, fileDataMap[prefix]);
        }
      }
    });
    document.getElementById('chkLongTrades').addEventListener('change', function() {
      for (const prefix in fileDataMap) {
        if (fileDataMap.hasOwnProperty(prefix)) {
          updateChartsForFile(prefix, fileDataMap[prefix]);
        }
      }
    });
    document.getElementById('chkShortTrades').addEventListener('change', function() {
      for (const prefix in fileDataMap) {
        if (fileDataMap.hasOwnProperty(prefix)) {
          updateChartsForFile(prefix, fileDataMap[prefix]);
        }
      }
    });
  </script>
</body>
</html>
